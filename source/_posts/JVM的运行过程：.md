---
title: JVM探究
date: 2019.07.21 10:06
tags:
  - Java
description: JVM探究
copyright: true
---

## JVM的运行过程：

​	Java源文件，通过编译器，能够生产相应得.class字节码文件。而字节码文件又通过JVM中的解释器，编译成特定机器上的机器码。

- Java源文件-->编译器-->字节码文件
- 字节码文件-->JVM-->机器码

每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么可以跨平台的原因，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。

### 1、线程

​	线程指的是程序执行过程中的一个线程实体。JVM允许一个应用并发执行多个线程。Hotspot JVM中的Java线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好之后，就会创建一个操作系统原生的线程(守护线程Daemon)。Java线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它分配到任何可用的CPU上。**当原生线程初始化完毕，就会调用Java线程的run()方法。当线程结束时，会释放原生线程和Java线程的所有资源**。

Hotspot JVM后台运行的系统线程主要有下面几个：

| 线程                    |                             解释                             |
| :---------------------- | :----------------------------------------------------------: |
| 虚拟机线程（VM thread） | 这个线程等待JVM到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要JVM位于安全点。这些操作的类型有：stop-the-world垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased locking）解除 |
| 周期性任务线程          | 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行 |
| GC线程                  |             这些线程支持JVM中不同的垃圾回收活动              |
| 编译器线程              |    这些线程在运行时将字节码动态编译成本地平台相关的机器码    |
| 信号分发线程            |      这个线程接收发送到JVM的信号并调用适当的JVM方法处理      |

### 3、JVM内存

#### 3.1、线程私有Thread Local

- 程序计数器PC

  - 指向虚拟机字节码指令的位置

  - 唯一一个无OOM的区域（OOM：Out Of Memory内存溢出）

- 虚拟机栈VM Stack

  - 虚拟机栈和线程的生命周期相同

  - 一个线程中，每调用一个方法创建一个栈帧（Stack Frame）

  - 栈帧的结构
    - 本地变量表Local Variable
    - 操作数栈Operand Stack
    - 对运行时常量池的引用 Runtime Constant Pool Reference

  - 异常
    - 线程请求的栈深度大于JVM所允许的深度StackOverflowError
    - 若JVM允许动态扩展，若无法申请到足够内存OutOfMemoryError

- 本地方法栈Native Method Stack
  - 异常
    - 线程请求的栈深度大于JVM所允许的深度StackOverflowError
    - 若JVM允许动态扩展，若无法申请到足够内存OutOfMemoryError

- 线程共享Thread Shared

  - 方法区（永久代）Method Area
    - 运行时常量池Runtime Constant Pool

  - 类实例区（Java堆）Objects

    - 新生代
      - eden
      - from survivor
      - to survivor

    - 老年代

    - 异常OutOfMemoryError

- 直接内存Direct Memory
  - 不受JVM GC管理

#### 3.2、JVM内存区域解释

JVM内存区域主要分为：

1. 线程私有区域：程序计数器、虚拟机栈、本地方法栈
2. 线程共享区域：Java堆，方法区
3. 直接内存

**线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束，而创建/销毁在Hotspot JVM内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应。**

**线程共享区域随虚拟机JVM的启动/关闭而创建/销毁**

**直接内存并不是JVM运行时数据区的一部分，但也会被频繁的使用：在JDK1.4引入的NIO提供了基于Channel与Buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后使用DirectByteBuffer对象作为这块内存的引用进行操作，这样就避免了在Java堆和Native堆中来回复制数据，因此在一些场景中可以显著提供性能。**

##### 1、程序计数器（线程私有）

​	一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

​	正在执行Java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。

​	这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。

##### 2、虚拟机栈（线程私有）

​	是描述Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）,用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

​	栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）、方法返回值和异常分派(Dispatch Exception)。栈帧随着方法调用而创建，随着方法结束而摧毁---无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

- 当前线程：
  - 当前栈帧Current Stack Frame
    - 局部变量表
    - 操作栈
    - 动态链接
    - 返回地址

#####  3、本地方法区（线程私有）

​	本地方法区和Java Stack作用类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务，如果一个VM实现使用C-linkage模型来支持Native调用，那么该栈将会是一个C栈，但是HotSpot VM直接就把本地方法栈和虚拟机栈合二为一。

##### 4、堆（Heap-线程共享）-运行时数据区

​	是被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM采用分代收集算法，因此Java堆从GC的角度还可以细分为：新生代(Eden区，From Survivor区、To Survivor区)和老年代。

##### 5、方法区/永久代（线程共享）

​	我们常说的永久代（Permanent Generation），用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。HotSpot VM把GC分代收集扩展到方法区，也就是使用Java堆的永久代来实现方法区，这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存，而不必为方法区开发专门的内存管理器（永久代的内存回收的主要目标是针对常量池的回收和类型的卸载，因此收益一般很小）

​	运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。

#### 3.3、JVM运行时内存

Java堆从GC的角度还可以细分为：新生代（Eden区、From Survivor区和To Survivor区）和老年区

堆（Heap）

新生代（1/3）堆空间 ：Eden(8/10)，From Survivor(1/10)，To Survivor(1/10)

老年代(2/3)堆空间

##### 1、新生代

​	用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为Eden区、From Survivor区，To Survivor三个区。

- Eden区

  Java新对象的出生地 （如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。

- From Survivor区

  上一次GC的幸存者，作为这一次GC的被扫描者

- To Survivor区

  保留了一次MinorGC过程中的幸存者

- MinorGC的过程

  复制--->清空--->互换

  MinorGC采用复制算法。

###### 1、 Eden、From Survivor复制到To Survivor，年龄+1

​	首先，把Eden和From Survivor区域中存活的对象复制到To Survivor区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年区)，同时把这些对象的年龄+1（如果To Survivor不够位置了就放到老年区）

###### 2、清空Eden、From Survivor

​	然后，清空Eden和From Survivor中的对象 。

###### 3、To Survivor和From Survivor互换

​	最后，To Survivor和From Survivor互换，原To Survivor成为下一次GC的From Survivor区。

##### 2、老年代

​	主要存放应用程序中生命周期长的内存对象。

​	老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象的时候，也会提前触发一次MajorGC进行了垃圾回收腾出空间。

​	MajorGC采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收 。MajorGC会产生 内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM(OutOfMemory)异常。

##### 3、永久代

​	内存的永久保存区域。主要存放Class和Meta(元数据)的信息，Class被加载的时候被放入永久区域，它和存放实例的区域不同，GC不会再逐层序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。

###### 1、Java8与Meta元数据

​	在Java8中，永久代已经被移除，被一个成为元数据区(元空间)的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别是：元空间并不在虚拟机中，而是使用本地内存。在默认情况下，元空间的大小仅受本地内存限制，类的元数据放入Native Memory，字符串池和静态变量放入Java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

#### 4、垃圾回收与算法

